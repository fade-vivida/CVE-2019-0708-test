# cve-2019-0708 #

# 1. 漏洞成因分析 #
## 1.1 RDP 协议介绍 ##

远程桌面协议（RDP，RemoteDesktop Protocol）是一个多通道（multi-channel）的协议。

RDP协议也是C/S网络结构，双方通过TCP连接进行通信，基本也是基于请求/响应这样的数据交换模式，这里贴一张来自微软发布的RDP协议时序图，该图详细描述了RDP连接中请求及响应的顺序及过程。

RDP协议中请求与响应顺序如下所示：  
![rdp](https://raw.githubusercontent.com/fade-vivida/CVE-2019-0708/master/IMG/RDP.PNG)

**注：PDU ( Protocol Data Unit )，协议数据单元**

该文档（[MS-RDPBCGR].pdf）地址如下：[https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpbcgr/5073f4ed-1e93-45e1-b039-6e30c385867c](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpbcgr/5073f4ed-1e93-45e1-b039-6e30c385867c)。

## 1.2 静态虚拟通道（Static Virtual Channels） ##

静态虚拟通道允许 RDP-Client 和 RDP-Server 通过主 RDP 数据连接通信。虚拟通道数据是特定于应用程序的，对RDP不透明。连接时最多可以创建 31 个静态虚拟通道。 RDP-Client 在连接序列的 Basic Settings Exchange 阶段请求并确认所需虚拟通道列表，并在Channel Connection 阶段进行信道的连接。

每个虚拟通道充当独立的数据流。RDP-Client 和 RDP-Server 检查在每个虚拟通道上接收的数据，并将数据流路由到适当的处理函数以进行进一步处理。

## 1.3 漏洞成因 ##
CVE-2019-0708为一个UAF漏洞，即指针释放后再次发生了引用。

触发该漏洞的过程如下所示：  

1. RDP 建立连接，RDP-Server 调用 **termdd!IcaCreateChannel()** 函数创建 MS\_T120 静态虚拟信道，并绑定到 0x1f 信道号上，这是该信道的第一次绑定。（该操作发生于 RDP 建立的初期，可以认为是系统的默认操作）

2. RDP-Client 在与 RDP-Server 通信的 Channel Connection 阶段告知 RDP-Server 要绑定名称为 "MS\_T120" 的信道到指定信道，此时 RDP-Server 端在函数 **termdd!IcaBindVirtualChannels()** 中通过调用 **termdd!IcaFindChannelByName()** 函数得到之前创建的默认 MS\_T120 信道，然后将该信道绑定到用户指定的信道号上，此时完成 MS\_T120 信道的第二次绑定。（该操作有用户控制，此时可以认为在信道号数组中同时保留了两份 MS\_T120 信道的指针）

3. 然后 RDP-Client 通知 RDP-Server 断开第二次绑定的信道，该操作会使得 RDP-Server 调用 **termdd!IcaFreeChannel()** 函数释放该信道对象（MS\_T120）占用的空间。

4. 然后 RDP-Client 通知 RDP-Server 关闭 RDP 连接，RDP-Server 会调用 **!SignalBrokenConnection()** 函数释放信道号为 0x1f 的 MS\_T120 的信道对象。但由于该对象已经在步骤3中被释放过，这里再次调用 **termdd!IcaFreeChannel()** 函数执行清理操作，其中 **termdd!ExDeleteResourceLite()** 会引用该对象的数据而造成 UAF 漏洞

## 1.4 漏洞调试 ##
首先，我们需要知道 MS\_T120 信道是何时被创建的。

从上面 RDP 协议的介绍中我们可以知道，RDP协议在通信的时候需要定义静态虚拟信道，而 MS\_T120 信道就是其中一个。因此，MS\_T120 在 RDP 协议建立之初，就会由 RDP 服务端主动创建。我们可以通过对 **termdd!icaCreateChannel()** 函数下断点，看到该信道创建的过程（**注：该步骤可以通过使用微软远程桌面连接工具来实现，不用POC**）。

IcaCreateChannel() 函数静态分析结果如下所示：  

![create_channel](https://raw.githubusercontent.com/fade-vivida/CVE-2019-0708/master/IMG/channel_create.PNG)

动态调试结果：  
![cc_debug](https://raw.githubusercontent.com/fade-vivida/CVE-2019-0708/master/IMG/cc_debug.PNG)

在函数 **IcaAllocateChannel()** 中，首先会调用 **ExAllocatePoolWithTag()** 函数申请 0x8c （xp）大小的池缓冲用来保存信道对象，然后会对信道对象进行一系列初始化操作。接着，会首先调用 **IcaFindVcBind()** 函数得到对于 MS\_T120 信道系统默认的信道号（调试结果为0x1f），最后调用 **IcaBindChannel()** 函数将 MS\_T120 信道绑定到信道号 0x1f 上。

![allocate_channel](https://raw.githubusercontent.com/fade-vivida/CVE-2019-0708/master/IMG/channel_alloc.PNG)

调试结果如下所示：  

IcaFindVcBind() 函数通过遍历一个链表来得到系统默认的信道与信道号的对应关系。从调试中我们可以看出，当前系统中有两个对应关系，分别为：CTXTW（信道）--> 7（信道号） 和 MS\_T120（信道）--> 31（信道号）。

![ctxtw](https://raw.githubusercontent.com/fade-vivida/CVE-2019-0708/master/IMG/ctxtw.PNG)

![mst120](https://raw.githubusercontent.com/fade-vivida/CVE-2019-0708/master/IMG/mst120.PNG)

调用 IcaBindChannel() 进行信道号绑定  

![channel_bind](https://raw.githubusercontent.com/fade-vivida/CVE-2019-0708/master/IMG/channel_bind.PNG)

至此，触发漏洞过程的步骤1完成。

## 2. RDP协议解析 ##
对漏洞利用过程中关键数据包的格式进行详细分析
### 2.1 Client X.224 Connection Request PDU ###
X.224连接请求PDU是在RDP连接序列的连接启动阶段从客户端发送到服务器的RDP连接序列PDU（有关RDP连接顺序阶段的，请参见第1.1节），
该数据包格式如下所示：  
![c2s0](https://raw.githubusercontent.com/fade-vivida/CVE-2019-0708/master/IMG/c2s0.PNG)  
从实际数据包的分析中我们可以大概得到如下几个关键字段的构造信息：  

1. **tpktHeader（4byte）**: `0300002e`，其中 0x2e 为length字段
2. **x224Crq（7byte）**: `29e00000000000`
3. **cookie（variable）**: 形如 "Cookie: mstshash=IDENTIFIER" ，其中IDENTIFIER为一个ASCII字符串，以 \x0d\x0a 结尾
4. **rdpNegReq（8byte）**：RDP（RDP Negotiation Request）协商请求，形如：`0100080000000000`，具体字段信息可以在[https://github.com/fade-vivida/CVE-2019-0708/blob/master/Reference/%5BMS-RDPBCGR%5D.pdf](https://github.com/fade-vivida/CVE-2019-0708/blob/master/Reference/%5BMS-RDPBCGR%5D.pdf) 中（章节2.2.1.1.1）查看。

数据包实例如下图所示：
![wire_rdp0](https://raw.githubusercontent.com/fade-vivida/CVE-2019-0708/master/IMG/wire_rdp0.PNG) 

### 2.2 Server X.224 Connection Confirm PDU ###
X.224连接确认PDU是在RDP连接序列的启动阶段期间从服务器发送到客户端的RDP连接序列PDU（有关RDP连接序列阶段的概述，请参见第1.1节），它作为对X.224连接请求PDU的响应发送（第2.1节）。其数据包格式如下所示：  
![s2c1](https://raw.githubusercontent.com/fade-vivida/CVE-2019-0708/master/IMG/s2c1.PNG)  

1. **tpktHeader（4byte）**: `0300000b`
2. **x224Ccf（7byte）**: `06d00000123400`

数据包实例如下图所示：
![wire_rdp1](https://raw.githubusercontent.com/fade-vivida/CVE-2019-0708/master/IMG/wire_rdp1.PNG) 

### 2.3 Client MCS Connect Initial PDU with GCC Conference Create Request ###
MCS（Multipoint communication service） Connect Initial PDU 是在 RDP 连接序列的基本设置交换阶段期间从客户端发送到服务器的 RDP 连接序列 PDU 。它在收到 X.224 连接确认 PDU （第2.2节）后发送。 MCS Connect Initial PDU 封装了 GCC 创建请求，该请求封装了连接的设置数据块。

![cmc_initial](https://raw.githubusercontent.com/fade-vivida/CVE-2019-0708/master/IMG/CMC_Initial_pdu.PNG)  
![cmc_initial2](https://raw.githubusercontent.com/fade-vivida/CVE-2019-0708/master/IMG/CMC_Initial_pdu2.PNG)  

1. **tpktHeader（4byte）**：A TPKT Header
2. **x224Ccf（3byte）**：An X.224 Class 0 Data TPDU
3. **mcsCi（variable）**：MCS Connect Initial 的 **UserData** 封装 GCC 会话创建请求数据（包含在 **gccCCrq** 字段和后续字段中）。 如果服务器没有通告对扩展客户端数据的支持，则 **UserData** 的最大允许大小为 1024 字节，**gccCCrq** 和后续字段的总大小必须小于1024字节。 反之，如果服务器确实通告了对扩展客户端数据的支持，则 **UserData** 的最大允许大小为 4096 字节，**gccCCrq** 和后续字段必须小于4096字节。**MCS T.125**
4. **gccCCrq (variable)**：GCC会话创建请求，**GCC T.124**
5. **clientCoreData**：可变长度的 **Client Core Data** 结构，关键数据包结构，详细分析见下文
6. **client**

其他具体字段含义可以参见 RDP PDF 文档。
### 2.3.1 User Data Header (TS\_UD\_HEADER) ###

User Data Field 主要有数据包头和数据内容两部分组成，其中数据包头为 4 个字节，包含之后数据包的类型和长度（包含包头在内）
![userdata_header](https://raw.githubusercontent.com/fade-vivida/CVE-2019-0708/master/IMG/user_data_header.PNG)

具体数据包类型如下所示：  
![userdata_type](https://raw.githubusercontent.com/fade-vivida/CVE-2019-0708/master/IMG/userdata_type.PNG)  

### 2.3.2 Client Core Data (TS\_UD\_CS\_CORE) ###
该数据包包含多个连接相关信息，其 User Data Field 的 type 字段必须为 0xc001（CS_CORE）。
![user_core0](https://raw.githubusercontent.com/fade-vivida/CVE-2019-0708/master/IMG/user_core0.PNG)  
![user_core1](https://raw.githubusercontent.com/fade-vivida/CVE-2019-0708/master/IMG/user_core1.PNG)  
![user_core2](https://raw.githubusercontent.com/fade-vivida/CVE-2019-0708/master/IMG/user_core2.PNG)  

下面对其关键字段进行解释：  

1. **SASSequence (2 bytes)**：该字段必须为 0xaa03（RNS_UD_SAS_DEL）。
2. **clientBuild (4 bytes)**：32位无符号整数，客户端的 build number。
3. **clientName（32 bytes）**：一个以null结尾的 unicode 字符串，最多15个字符。
4. **clientProductId (2 bytes)**：该字段必须被初始化为1。
5. **serialNumber（4 bytes）**：该字段需要被初始化为0。

### 2.3.3 Client Security Data (TS\_UD\_CS\_SEC) ###
TS\_UD\_CS\_SEC 数据包包含用于通告客户端所支持的加密安全相关信息。

![user_data_secu](https://raw.githubusercontent.com/fade-vivida/CVE-2019-0708/master/IMG/user_data_secu.PNG)  

具体支持的写加密协议可以参见 RDP PDF 文档。
### 2.3.4 Client Network Data (TS\_UD\_CS\_NET) ###
TS\_UD\_CS\_NET分组包含所请求的虚拟信道的列表（触发漏洞的关键数据包）
![user_channel](https://raw.githubusercontent.com/fade-vivida/CVE-2019-0708/master/IMG/user_channel.PNG)  

其数据包 header 字段的 type 域必须为 CS_NET(0xC003)，channelCount表示请求的静态虚拟通道数（最大为31），channelDefArray 则为一个个 **Channel Definition Structure (CHANNEL\_DEF)** 结构体，该结构体主要有两个字段，一个为 name 字段表明虚拟通道的名称，一个为该虚拟通道的一些选项表示。

具体事例如下所示：  

![user_net](https://raw.githubusercontent.com/fade-vivida/CVE-2019-0708/master/IMG/user_net.PNG)  
我们可以看到，在 poc 中一共申请了4个虚拟信道，并将 MS\_T120 虚拟信道绑定到了信道号2和3上。

### 2.4 Server MCS Connect Response PDU with GCC Conference Create Response ###
MCS 连接响应 PDU 是在 RDP 连接序列的基本设置交换阶段从服务器发送到客户端的 RDP 连接序列 PDU，作为对 MCS Connect Initial PDU 的响应。 MCS Connect Response PDU 封装了 GCC 会议创建响应，该响应封装了连接的设置数据载荷。 

该数据包的结构与 MCS Connection Initial PDU Request 数据包结构相似我们主要关心该数据包中与漏洞触发相关的字段