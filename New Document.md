# cve-2019-0708 #

# 1. 漏洞成因分析 #
## 1.1 RDP 协议介绍 ##

远程桌面协议（RDP，RemoteDesktop Protocol）是一个多通道（multi-channel）的协议。

RDP协议也是C/S网络结构，双方通过TCP连接进行通信，基本也是基于请求/响应这样的数据交换模式，这里贴一张来自微软发布的RDP协议时序图，该图详细描述了RDP连接中请求及响应的顺序及过程。

RDP协议中请求与响应顺序如下所示：  
![rdp](https://raw.githubusercontent.com/fade-vivida/CVE-2019-0708/master/IMG/RDP.PNG)

**注：PDU ( Protocol Data Unit )，协议数据单元**

该文档（[MS-RDPBCGR].pdf）地址如下：[https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpbcgr/5073f4ed-1e93-45e1-b039-6e30c385867c](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpbcgr/5073f4ed-1e93-45e1-b039-6e30c385867c)。

## 1.2 静态虚拟通道（Static Virtual Channels） ##

静态虚拟通道允许 RDP-Client 和 RDP-Server 通过主 RDP 数据连接通信。虚拟通道数据是特定于应用程序的，对RDP不透明。连接时最多可以创建 31 个静态虚拟通道。 RDP-Client 在连接序列的 Basic Settings Exchange 阶段请求并确认所需虚拟通道列表，并在Channel Connection 阶段进行信道的连接。

每个虚拟通道充当独立的数据流。RDP-Client 和 RDP-Server 检查在每个虚拟通道上接收的数据，并将数据流路由到适当的处理函数以进行进一步处理。

## 1.3 漏洞成因 ##
CVE-2019-0708为一个UAF漏洞，即指针释放后再次发生了引用。

触发该漏洞的过程如下所示：  

1. RDP 建立连接，RDP-Server 调用 **termdd!IcaCreateChannel()** 函数创建 MS\_T120 静态虚拟信道，并绑定到 0x1f 信道号上，这是该信道的第一次绑定。（该操作发生于 RDP 建立的初期，可以认为是系统的默认操作）

2. RDP-Client 在与 RDP-Server 通信的 Channel Connection 阶段告知 RDP-Server 要绑定名称为 "MS\_T120" 的信道到指定信道，此时 RDP-Server 端在函数 **termdd!IcaBindVirtualChannels()** 中通过调用 **termdd!IcaFindChannelByName()** 函数得到之前创建的默认 MS\_T120 信道，然后将该信道绑定到用户指定的信道号上，此时完成 MS\_T120 信道的第二次绑定。（该操作有用户控制，此时可以认为在信道号数组中同时保留了两份 MS\_T120 信道的指针）

3. 然后 RDP-Client 通知 RDP-Server 断开第二次绑定的信道，该操作会使得 RDP-Server 调用 **termdd!IcaFreeChannel()** 函数释放该信道对象（MS\_T120）占用的空间。

4. 然后 RDP-Client 通知 RDP-Server 关闭 RDP 连接，RDP-Server 会调用 **!SignalBrokenConnection()** 函数释放信道号为 0x1f 的 MS\_T120 的信道对象。但由于该对象已经在步骤3中被释放过，这里再次调用 **termdd!IcaFreeChannel()** 函数执行清理操作，其中 **termdd!ExDeleteResourceLite()** 会引用该对象的数据而造成 UAF 漏洞

## 1.4 漏洞调试 ##
首先，我们需要知道 MS\_T120 信道是何时被创建的。

从上面 RDP 协议的介绍中我们可以知道，RDP协议在通信的时候需要定义静态虚拟信道，而 MS\_T120 信道就是其中一个。因此，MS\_T120 在 RDP 协议建立之初，就会由 RDP 服务端主动创建。我们可以通过对 **termdd!icaCreateChannel()** 函数下断点，看到该信道创建的过程（**注：该步骤可以通过使用微软远程桌面连接工具来实现，不用POC**）。

IcaCreateChannel() 函数静态分析结果如下所示：  

![create_channel](https://raw.githubusercontent.com/fade-vivida/CVE-2019-0708/master/IMG/channel_create.PNG)

动态调试结果：  
![cc_debug](https://raw.githubusercontent.com/fade-vivida/CVE-2019-0708/master/IMG/cc_debug.PNG)

在函数 **IcaAllocateChannel()** 中，首先会调用 **ExAllocatePoolWithTag()** 函数申请 0x8c （xp）大小的池缓冲用来保存信道对象，然后会对信道对象进行一系列初始化操作。接着，会首先调用 **IcaFindVcBind()** 函数得到对于 MS\_T120 信道系统默认的信道号（调试结果为0x1f），最后调用 **IcaBindChannel()** 函数将 MS\_T120 信道绑定到信道号 0x1f 上。

![allocate_channel](https://raw.githubusercontent.com/fade-vivida/CVE-2019-0708/master/IMG/channel_alloc.PNG)

调试结果如下所示：  

IcaFindVcBind() 函数通过遍历一个链表来得到系统默认的信道与信道号的对应关系。从调试中我们可以看出，当前系统中有两个对应关系，分别为：CTXTW（信道）--> 7（信道号） 和 MS\_T120（信道）--> 31（信道号）。

![ctxtw](https://raw.githubusercontent.com/fade-vivida/CVE-2019-0708/master/IMG/ctxtw.PNG)

![mst120](https://raw.githubusercontent.com/fade-vivida/CVE-2019-0708/master/IMG/mst120.PNG)

调用 IcaBindChannel() 进行信道号绑定  

![channel_bind](https://raw.githubusercontent.com/fade-vivida/CVE-2019-0708/master/IMG/channel_bind.PNG)

至此，触发漏洞过程的步骤1完成。

## 2. RDP协议解析 ##
对漏洞利用过程中关键数据包的格式进行详细分析
### 2.1 Client X.224 Connection Request PDU ###
X.224连接请求PDU是在RDP连接序列的连接启动阶段从客户端发送到服务器的RDP连接序列PDU（有关RDP连接顺序阶段的，请参见第1.1节），
该数据包格式如下所示：  

![c2s0](https://raw.githubusercontent.com/fade-vivida/CVE-2019-0708/master/IMG/c2s0.PNG)
